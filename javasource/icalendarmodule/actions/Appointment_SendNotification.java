// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package icalendarmodule.actions;

import icalendarmodule.proxies.Encryption;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.text.ParseException;
import java.util.Properties;
import javax.activation.CommandMap;
import javax.activation.MailcapCommandMap;
import javax.mail.Address;
import javax.mail.Authenticator;
import javax.mail.BodyPart;
import javax.mail.Message.RecipientType;
import javax.mail.MessagingException;
import javax.mail.Multipart;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.mail.internet.MimeMultipart;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.DateTime;
import net.fortuna.ical4j.model.Property;
import net.fortuna.ical4j.model.TimeZone;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.component.VTimeZone;
import net.fortuna.ical4j.model.parameter.PartStat;
import net.fortuna.ical4j.model.parameter.Role;
import net.fortuna.ical4j.model.parameter.Rsvp;
import net.fortuna.ical4j.model.property.Attendee;
import net.fortuna.ical4j.model.property.CalScale;
import net.fortuna.ical4j.model.property.Description;
import net.fortuna.ical4j.model.property.Location;
import net.fortuna.ical4j.model.property.Method;
import net.fortuna.ical4j.model.property.Organizer;
import net.fortuna.ical4j.model.property.ProdId;
import net.fortuna.ical4j.model.property.Sequence;
import net.fortuna.ical4j.model.property.Uid;
import net.fortuna.ical4j.model.property.Version;
import net.fortuna.ical4j.zoneinfo.outlook.OutlookTimeZoneRegistryFactory;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;

/**
 * 
 */
public class Appointment_SendNotification extends CustomJavaAction<Boolean>
{
	private String UID;
	private icalendarmodule.proxies.NotificationType VCalendarType;
	private Long UpdateSequenceNr;
	private java.util.Date StartDateTime;
	private java.util.Date EndDateTime;
	private String Subject;
	private String BodyText;
	private String Location;
	private String RecipientEmailAddress;
	private String SenderEmailAddress;
	private String TimeZoneID;
	private IMendixObject __settingsObj;
	private icalendarmodule.proxies.SMTPSettings settingsObj;

	public Appointment_SendNotification(IContext context, String UID, String VCalendarType, Long UpdateSequenceNr, java.util.Date StartDateTime, java.util.Date EndDateTime, String Subject, String BodyText, String Location, String RecipientEmailAddress, String SenderEmailAddress, String TimeZoneID, IMendixObject settingsObj)
	{
		super(context);
		this.UID = UID;
		this.VCalendarType = VCalendarType == null ? null : icalendarmodule.proxies.NotificationType.valueOf(VCalendarType);
		this.UpdateSequenceNr = UpdateSequenceNr;
		this.StartDateTime = StartDateTime;
		this.EndDateTime = EndDateTime;
		this.Subject = Subject;
		this.BodyText = BodyText;
		this.Location = Location;
		this.RecipientEmailAddress = RecipientEmailAddress;
		this.SenderEmailAddress = SenderEmailAddress;
		this.TimeZoneID = TimeZoneID;
		this.__settingsObj = settingsObj;
	}

	@Override
	public Boolean executeAction() throws Exception
	{
		this.settingsObj = __settingsObj == null ? null : icalendarmodule.proxies.SMTPSettings.initialize(getContext(), __settingsObj);

		// BEGIN USER CODE
		MailcapCommandMap mc = (MailcapCommandMap) CommandMap.getDefaultCommandMap(); 
		mc.addMailcap("text/html;; x-java-content-handler=com.sun.mail.handlers.text_html"); 
		mc.addMailcap("text/xml;; x-java-content-handler=com.sun.mail.handlers.text_xml"); 
		mc.addMailcap("text/plain;; x-java-content-handler=com.sun.mail.handlers.text_plain"); 
		mc.addMailcap("multipart/*;; x-java-content-handler=com.sun.mail.handlers.multipart_mixed"); 
		mc.addMailcap("message/rfc822;; x-java-content- handler=com.sun.mail.handlers.message_rfc822"); 
		mc.addMailcap("text/calendar;; x-java-content-handler=com.sun.mail.handlers.text_plain");
		
		Calendar calendar = this.createCalendar( );

		this.mail( calendar );
		
		return true;
		
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public String toString()
	{
		return "Appointment_SendNotification";
	}

	// BEGIN EXTRA CODE
	
	private void mail( Calendar calendar ) throws MessagingException{
		
		// Initialization etc...
		Encryption ssl = this.settingsObj.getSMTPEncryption( );
		int smtpPort = this.settingsObj.getSMTPPort( );
		
		String
			smtpHost     = this.settingsObj.getSMTPHost( ), // "10.140.10.18"
			smtpUsername = this.settingsObj.getSMTPUsername( ),
			smtpPassword = this.settingsObj.getSMTPPassword( ),
			
			mailFrom = this.SenderEmailAddress;
		
		smtpHost = smtpHost == null ? "" : smtpHost;
		smtpPort = smtpPort <= 0    ? 25 : smtpPort;
		
//		smtpUsername = smtpUsername == null ? "" : smtpUsername;
//		smtpPassword = smtpPassword == null ? "" : smtpPassword;		
		
		Properties properties = new Properties( );
		
		properties.put( "mail.smtp.starttls.enable", ( ssl == Encryption.TLS ) );
		properties.put( "mail.smtp.host", smtpHost );
		properties.put( "mail.smtp.port", Integer.toString( smtpPort ) );
		
		if( smtpUsername!=null && !smtpUsername.isEmpty() ) {
			properties.put( "mail.smtp.auth", true );
			properties.put( "mail.smtp.user",     smtpUsername );
			properties.put( "mail.smtp.password", smtpPassword );
		}
		else 
			properties.put( "mail.smtp.auth", false );

	    SmtpAuthenticator authentication = new SmtpAuthenticator(smtpUsername, smtpPassword);
		Session session = Session.getDefaultInstance( properties, authentication );

		// Create the actual message and configure it.
	    MimeMessage message = new MimeMessage( session );
	    
		message.addHeaderLine( "method=REQUEST" );
		message.addHeaderLine( "charset=UTF-8" );
		message.addHeaderLine( "component=VEVENT" );
		
		// Make sure the "sender" also gets a copy of the invitation so it can be planned in his/her agenda as well.		
		message.setFrom( new InternetAddress( mailFrom ) );
		
		for( String mail : this.getAttendees( ) ){
			Address address = new InternetAddress( mail );
			message.addRecipient( RecipientType.TO, address );
		}
		
		// Create the body of the message
		BodyPart body = new MimeBodyPart( );
		
		body.setHeader( "Content-Class", "urn:content-classes:calendarmessage" );
		body.setHeader( "Content-ID",    "calendar_message" );
		
		body.setContent( calendar.toString( ), "text/calendar" );
		
		// The container we are going to stick into the message, that message will be sent over
		// the wire all over the world.
		Multipart multipart = new MimeMultipart( );
		
		multipart.addBodyPart( body );
		
		message.setSubject( this.Subject );
		message.setContent( multipart );

			// Lets get this shit on the road!
			Transport  transport;
			if( ssl == Encryption.SSL )
				transport = session.getTransport( "smtps" );
			else
				transport = session.getTransport( "smtp" );
				
			
			transport.connect(
				smtpHost,
				smtpPort ,
				smtpUsername,
				smtpPassword
			);
			Thread.currentThread().setContextClassLoader( getClass().getClassLoader());
			transport.sendMessage( message, message.getAllRecipients( ) );
			transport.close( );
	}
	
	private Calendar createCalendar( ) throws IOException, URISyntaxException, ParseException{
		// HACK: The start and end are supplied as a Date so convert them magically to a DateTime.
		DateTime start = new DateTime( this.StartDateTime ),
				 end   = new DateTime( this.EndDateTime );
		
		OutlookTimeZoneRegistryFactory timeZoneRegistry = new OutlookTimeZoneRegistryFactory();
		TimeZone timezone = timeZoneRegistry.createRegistry().getTimeZone( this.TimeZoneID );	
		
		VTimeZone vt = timezone.getVTimeZone();
		
		// The event component with all the stuff we need.
		//
		VEvent event = new VEvent( start, end, this.Subject );
		
		Property
			organizer   = new Organizer( URI.create( "mailto:" + this.SenderEmailAddress ) ),
			description = new Description( this.BodyText ),
			uid         = new Uid( this.UID ),
			location    = new Location( this.Location ),
			sequence    = new Sequence( ( this.UpdateSequenceNr.toString( ) ) );
		
		event.getProperties( ).add( sequence );
		event.getProperties( ).add( organizer );
		event.getProperties( ).add( uid );
		event.getProperties( ).add( location );
		event.getProperties( ).add( description );
		
		for( String mail : this.getAttendees( ) ){
			Attendee attendee = new Attendee( URI.create( "mailto:" + mail ) );
			
			attendee.getParameters( ).add( Role.REQ_PARTICIPANT );
			attendee.getParameters( ).add( PartStat.NEEDS_ACTION );
			attendee.getParameters( ).add( Rsvp.TRUE );
			
			event.getProperties( ).add( attendee );
		}
		
		// The calendar, this thing is the java representation of our complete appointment, stick all
		// all the stuff we made in here and serialize.
		Calendar calendar = new Calendar( );
				
		calendar.getProperties( ).add( 
			  this.VCalendarType.toString( ).equalsIgnoreCase( "create" ) ? Method.REQUEST
			: this.VCalendarType.toString( ).equalsIgnoreCase( "update" ) ? Method.REQUEST
			: this.VCalendarType.toString( ).equalsIgnoreCase( "cancel" ) ? Method.CANCEL
			: Method.CANCEL // In case we have an invalid calendar request we will generate a cancel request, I wish there was an error method...				
		);
		calendar.getProperties( ).add( new ProdId( "-//Mendix//iCal4j 1.0.4" ) );
		calendar.getProperties( ).add( Version.VERSION_2_0 );
		calendar.getProperties( ).add( CalScale.GREGORIAN );
		
		calendar.getComponents( ).add( vt );
		calendar.getComponents( ).add( event );
		
		return calendar;
	}
	
	private String[ ] attendees;
	
	private String[ ] getAttendees( ){
		if( this.attendees == null ){
			this.attendees = this.RecipientEmailAddress.split( "[,;]" );
			
			for( int i = 0; i < this.attendees.length; i++ ){
				this.attendees[ i ] = this.attendees[ i ].trim( );
			}
		}
		
		return this.attendees;
	}
	
	public class SmtpAuthenticator extends Authenticator {
		String username;
		String password;
		public SmtpAuthenticator(String username, String password) {
		    super();
		    this.username = username;
		    this.password = password;
		}

		@Override
		public PasswordAuthentication getPasswordAuthentication() {
		    if ((this.username != null) && (this.username.length() > 0) && (this.password != null) 
		      && (this.password.length   () > 0)) {

		        return new PasswordAuthentication(this.username, this.password);
		    }

		    return null;
		}
	}
	
	// END EXTRA CODE
}
